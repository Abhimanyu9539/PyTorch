# -*- coding: utf-8 -*-
"""02_pytorch_classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xo4q5f0MOyKpUYh_bsZjhbLmVNGXb4sN

## Make Classification data
"""

import sklearn

from sklearn.datasets import make_circles

n_samples = 1000

# Create circles
X, y =  make_circles(n_samples,
                     noise = 0.03,
                     random_state=42)

len(X), len(y)

print(X[:5])

print(y[:5])

# Make dataframe
import pandas as pd
circles = pd.DataFrame({"X1": X[:,0],
                        "X2": X[:,1],
                        "label":y
                        })
circles.head(10)

# visualize
import matplotlib.pyplot as plt
plt.scatter(x=X[:, 0],
            y=X[:,1],
            c=y,
            cmap = plt.cm.RdYlBu);

"""### Check input and output shapes"""

X.shape, y.shape

X

# View first example of features and labels
X_sample = X[0]
y_sample = y[0]

print(X_sample, X_sample.shape)
print(y_sample, y_sample.shape)

"""### 1.2 Turn Data into Tensors"""

# Turn data into tensors
import torch
from torch import nn
X = torch.from_numpy(X).type(torch.float)
y = torch.from_numpy(y).type(torch.float)

X[:5], y[:5], y.dtype

torch.manual_seed(42)

# Split the data
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X,
                                                    y,
                                                    test_size=0.2,
                                                    random_state=42)

X_train.shape, X_test.shape

"""### 2. Building a model"""

# Import libs
import torch
from torch import nn

# Make device agnostic code
device = "cuda" if torch.cuda.is_available() else "cpu"
device

## Construct a model

class CircleModelV0(nn.Module):
  def __init__(self):
    super().__init__()
    self.layer_1 = nn.Linear(in_features=2,
                             out_features=5)
    self.layer_2 = nn.Linear(in_features=5,
                             out_features=1)

  def forward(self, x):
    ## x --> layer_1 --> layer_2
    return self.layer_2(self.layer_1(x))


model_0 = CircleModelV0().to(device)
model_0

next(model_0.parameters()).device



